[

    {
        "ID":  "DAX_DIVISION_COLUMNS",
        "Name":  "Avoid division (use DIVIDE function instead)",
        "Category":  "DAX Expressions",
        "Description":  "Calculated Columns, Measures or Calculated Tables should not use the division symbol in their expressions (/) unless the denominator is a constant value. Instead, it is advised to always use the DIVIDE(\u003cnumerator\u003e,\u003cdenominator\u003e) function.",
        "Severity": 3,
        "Scope":  "Measure, CalculatedColumn, CalculatedTable",
        "Expression":  "Tokenize().Any(\n    Type = DIV and\n    Next.Type \u003c\u003e INTEGER_LITERAL and\n    Next.Type \u003c\u003e REAL_LITERAL\n)",
        "CompatibilityLevel":  1200,
    },
    {
        "ID": "AVOID_USING_MANY-TO-MANY_RELATIONSHIPS_ON_TABLES_USED_FOR_DYNAMIC_ROW_LEVEL_SECURITY",
        "Name": "[Performance] Avoid using many-to-many relationships on tables used for dynamic row level security",
        "Category": "Performance",
        "Description": "Using many-to-many relationships on tables which use dynamic row level security can cause serious query performance degradation. This pattern's performance problems compound when snowflaking multiple many-to-many relationships against a table which contains row level security. Instead, use one of the patterns shown in the article below where a single dimension table relates many-to-one to a security table.\r\n\r\nReference: https://www.elegantbi.com/post/dynamicrlspatterns",
        "Severity": 3,
        "Scope": "Table",
        "Expression": "UsedInRelationships.Any(FromCardinality == \"Many\" and ToCardinality== \"Many\")\r\nand\r\nRowLevelSecurity.Any(it.Length > 0)",
        "CompatibilityLevel": 1200
        
    },
    {
        "ID": "DAX_COLUMNS_FULLY_QUALIFIED",
        "Name": "[DAX Expressions] Column references should be fully qualified",
        "Category": "DAX Expressions",
        "Description": "Using fully qualified column references makes it easier to distinguish between column and measure references, and also helps avoid certain errors. When referencing a column in DAX, first specify the table name, then specify the column name in square brackets.\r\nReference: https://www.elegantbi.com/post/top10bestpractices",
        "Severity": 3,
        "Scope": "Measure, KPI, TablePermission, CalculationItem",
        "Expression": "DependsOn.Any(Key.ObjectType = \"Column\" and Value.Any(not FullyQualified))",
        "CompatibilityLevel": 1200
    },
    {
        "ID": "DAX_MEASURES_UNQUALIFIED",
        "Name": "[DAX Expressions] Measure references should be unqualified",
        "Category": "DAX Expressions",
        "Description": "Using unqualified measure references makes it easier to distinguish between column and measure references, and also helps avoid certain errors. When referencing a measure using DAX, do not specify the table name. Use only the measure name in square brackets.\r\nReference: https://www.elegantbi.com/post/top10bestpractices",
        "Severity": 3,
        "Scope": "Measure, CalculatedColumn, CalculatedTable, KPI, CalculationItem",
        "Expression": "DependsOn.Any(Key.ObjectType = \"Measure\" and Value.Any(FullyQualified))",
        "CompatibilityLevel": 1200
    },
    {
        "ID": "DATA_COLUMNS_MUST_HAVE_A_SOURCE_COLUMN",
        "Name": "[Error Prevention] Data columns must have a source column",
        "Category": "Error Prevention",
        "Description": "Data columns must have a source column. A data column without a source column will cause an error when processing the model.",
        "Severity": 3,
        "Scope": "DataColumn",
        "Expression": "string.IsNullOrWhitespace(SourceColumn)",
        "CompatibilityLevel": 1200
    },
    {
        "ID": "EXPRESSION_RELIANT_OBJECTS_MUST_HAVE_AN_EXPRESSION",
        "Name": "[Error Prevention] Expression-reliant objects must have an expression",
        "Category": "Error Prevention",
        "Description": "Calculated columns, calculation items and measures must have an expression. Without an expression, these objects will not show any values.",
        "Severity": 3,
        "Scope": "Measure, CalculatedColumn, CalculationItem",
        "Expression": "string.IsNullOrWhiteSpace(Expression)",
        "CompatibilityLevel": 1200
    },
    {
        "ID": "AVOID_THE_USERELATIONSHIP_FUNCTION_AND_RLS_AGAINST_THE_SAME_TABLE",
        "Name": "[Error Prevention] Avoid the USERELATIONSHIP function and RLS against the same table",
        "Category": "Error Prevention",
        "Description": "The USERELATIONSHIP function may not be used against a table which also leverages row-level security (RLS). This will generate an error when using the particular measure in a visual. This rule will highlight the table which is used in a measure's USERELATIONSHIP function as well as RLS.\r\n\r\nReference: https://blog.crossjoin.co.uk/2013/05/10/userelationship-and-tabular-row-security/",
        "Severity": 3,
        "Scope": "Table, CalculatedTable",
        "Expression": "Model.AllMeasures.Any(RegEx.IsMatch(Expression,\"(?i)USERELATIONSHIP\\s*\\(\\s*.+?(?=])\\]\\s*,\\s*'*\" + current.Name + \"'*\\[\"))\r\nand\r\nRowLevelSecurity.Any(it <> null)",
        "CompatibilityLevel": 1200
    },
    {
        "ID": "RELATIONSHIP_COLUMNS_SAME_DATA_TYPE",
        "Name": "[Error Prevention] Relationship columns should be of the same data type",
        "Category": "Error Prevention",
        "Description": "Columns used in a relationship should be of the same data type. Ideally, they will be of integer data type (see the related rule '[Formatting] Relationship columns should be of integer data type'). Having columns within a relationship which are of different data types may lead to various issues.",
        "Severity": 3,
        "Scope": "Relationship",
        "Expression": "FromColumn.DataType != ToColumn.DataType",
        "CompatibilityLevel": 1200
    },
    {
        "ID": "AVOID_INVALID_NAME_CHARACTERS",
        "Name": "[Error Prevention] Avoid invalid characters in names",
        "Category": "Error Prevention",
        "Description": "This rule identifies if a name for a given object in your model (i.e. table/column/measure) which contains an invalid character. Invalid characters will cause an error when deploying the model (and failure to deploy). This rule has a fix expression which converts the invalid character into a space, resolving the issue.",
        "Severity": 3,
        "Scope": "Table, Measure, Hierarchy, Level, Perspective, Partition, DataColumn, CalculatedColumn, CalculatedTable, CalculatedTableColumn, KPI, ModelRole, CalculationGroup, CalculationItem",
        "Expression": "Name.ToCharArray().Any(char.IsControl(it) and !char.IsWhiteSpace(it))",
        "FixExpression": "Name = string.Concat( it.Name.ToCharArray().Select( c => (char.IsControl(c) && !char.IsWhiteSpace(c)) ? ' ': c ))",
        "CompatibilityLevel": 1200
    },
    {
        "ID": "AVOID_INVALID_DESCRIPTION_CHARACTERS",
        "Name": "[Error Prevention] Avoid invalid characters in descriptions",
        "Category": "Error Prevention",
        "Description": "This rule identifies if a description for a given object in your model (i.e. table/column/measure) which contains an invalid character. Invalid characters will cause an error when deploying the model (and failure to deploy). This rule has a fix expression which converts the invalid character into a space, resolving the issue.",
        "Severity": 3,
        "Scope": "Table, Measure, Hierarchy, Level, Perspective, Partition, DataColumn, CalculatedColumn, CalculatedTable, CalculatedTableColumn, KPI, ModelRole, CalculationGroup, CalculationItem",
        "Expression": "Description.ToCharArray().Any(char.IsControl(it) and !char.IsWhiteSpace(it))",
        "FixExpression": "Description = string.Concat( it.Description.ToCharArray().Select( c => (char.IsControl(c) && !char.IsWhiteSpace(c)) ? ' ': c ))",
        "CompatibilityLevel": 1200
    },
    {
        "ID": "SET_ISAVAILABLEINMDX_TO_TRUE_ON_NECESSARY_COLUMNS",
        "Name": "[Error Prevention] Set IsAvailableInMdx to true on necessary columns",
        "Category": "Error Prevention",
        "Description": "In order to avoid errors, ensure that attribute hierarchies are enabled if a column is used for sorting another column, used in a hierarchy, used in variations, or is sorted by another column.",
        "Severity": 3,
        "Scope": "DataColumn, CalculatedColumn, CalculatedTableColumn",
        "Expression": "IsAvailableInMDX = false\r\n\r\nand\r\n(\r\nUsedInSortBy.Any()\r\nor\r\nUsedInHierarchies.Any()\r\nor\r\nUsedInVariations.Any()\r\nor\r\nSortByColumn != null\r\n)",
        "FixExpression": "IsAvailableInMDX = true",
        "CompatibilityLevel": 1200
    },
    {
        "ID": "OBJECTS_SHOULD_NOT_START_OR_END_WITH_A_SPACE",
        "Name": "[Formatting] Objects should not start or end with a space",
        "Category": "Formatting",
        "Description": "Objects should not start or end with a space",
        "Severity": 3,
        "Scope": "Model, Table, Measure, Hierarchy, Perspective, Partition, DataColumn, CalculatedColumn",
        "Expression": "Name.StartsWith(\" \") or Name.EndsWith(\" \")",
        "CompatibilityLevel": 1200
    },
        {
        "ID":  "APPLY_FORMAT_STRING_MEASURES",
        "Name":  "Provide format string for visible numeric measures",
        "Category":  "Formatting",
        "Description":  "Visible measures should have their Format String property assigned",
        "Severity":  3,
        "Scope":  "Measure",
        "Expression":  "IsVisible\nand string.IsNullOrWhitespace(FormatString)\nand (DataType = \"Int64\" or DataType = \"DateTime\" or DataType = \"Double\" or DataType = \"Decimal\")",
        "CompatibilityLevel":  1200,
    },
    {
        "ID": "NUMERIC_COLUMN_SUMMARIZE_BY",
        "Name": "[Formatting] Do not summarize numeric columns",
        "Category": "Formatting",
        "Description": "Numeric columns (integer, decimal, double) should have their SummarizeBy property set to \"None\" to avoid accidental summation in Power BI (create measures instead).",
        "Severity": 3,
        "Scope": "DataColumn, CalculatedColumn, CalculatedTableColumn",
        "Expression": "(\r\nDataType = \"Int64\"\r\nor \r\nDataType=\"Decimal\" \r\nor \r\nDataType=\"Double\"\r\n)\n\r\nand \r\nSummarizeBy <> \"None\"\r\n\nand not (IsHidden or Table.IsHidden)",
        "FixExpression": "SummarizeBy = AggregateFunction.None",
        "CompatibilityLevel": 1200
    }

]